using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Spangle.LusterBits.Generator;

[Generator]
public class LusterBitsGenerator : IIncrementalGenerator
{
    private const string MarkerAttrFullName = "Spangle.LusterBits.LusterCharmAttribute";

    private const string FieldAttributeName   = "BitFieldAttribute";
    private const string OptionsAttributeName = "BitFieldOptionsAttribute";

    private const int BitsPerByte  = 8;
    private const int PosLastBit   = 7;
    private const int AutoPosition = -1;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Gathering the target struct
        IncrementalValuesProvider<GeneratorAttributeSyntaxContext> source =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                MarkerAttrFullName,
                static (_, _) => true,
                static (context, _) => context
            );

        context.RegisterSourceOutput(source, Emit);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        if (!typeNode.Modifiers.Any(SyntaxKind.PartialKeyword))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotPartial,
                typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // Extract string tokens for template
        string ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";
        string accessibility = typeSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();

        // Get GenerateType from attribute constructor
        var generateType = (GenerateType)(source.Attributes
                                              .First(x => x.AttributeClass?.ToDisplayString() is MarkerAttrFullName)
                                              .ConstructorArguments.First().Value
                                          ?? throw new Exception("Something went wrong."));
        if (generateType.HasInvalidFlag())
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.InvalidGenerateType,
                typeNode.Identifier.GetLocation(), (byte)generateType));
            return;
        }

        // Search target fixed byte array with BitFieldAttribute
        var targetFields = (
            from member in typeSymbol.GetMembers()
            where member is IFieldSymbol { IsStatic: false, IsImplicitlyDeclared: false }
            where member.GetAttributes().Any(attr => attr.AttributeClass?.Name is FieldAttributeName)
            select (IFieldSymbol)member).ToArray();

        if (!targetFields.Any())
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NoSuitableFieldDefinitions,
                typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var propDefs = from target in targetFields
            from bf in target.GetAttributes().Where(attr => attr.AttributeClass?.Name is FieldAttributeName)
            select BitFieldInternal.FromConstructorArgs(target, bf);

        string baseTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var emitParams = new EmitterImplParams
        {
            Context = context,
            TypeNode = typeNode,
            HasInterface = (generateType & GenerateType.Interface) != 0,
            BaseFileName = baseTypeName,
            NameSpace = ns,
            TypeAccessibility = accessibility,
            TypeSymbol = typeSymbol,
            PropDefs = propDefs.ToArray(),
        };

        // Emit code for each type

        if (emitParams.HasInterface)
        {
            EmitInterface(emitParams);
        }

        if ((generateType & GenerateType.Expression) != 0)
        {
            EmitExpressionProperties(emitParams);
        }

        if ((generateType & GenerateType.Deserialized) != 0)
        {
            EmitDeserializedStruct(emitParams);
        }
    }

    private static void EmitInterface(EmitterImplParams emitParams)
    {
        StringBuilder codeBuilder = new StringBuilder().AppendLine($$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;

{{emitParams.NameSpace}}

{{emitParams.TypeAccessibility}} interface I{{emitParams.TypeSymbol.Name}}
{
""");
        foreach (var attr in emitParams.PropDefs)
        {
            if (attr.Description is not null)
            {
                codeBuilder.AppendLine($$"""
    /// <summary>
    /// {{attr.Description}}
    /// </summary>
""");
            }

            try
            {
                codeBuilder.AppendLine($$"""
    public {{GetSuitableTypeName(attr.PropType)}} {{attr.PropName}} { get; }

""");
            }
            catch (ArgumentException)
            {
                emitParams.Context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotSupportedTypeField,
                    emitParams.TypeNode.Identifier.GetLocation(), attr.PropType));
                return;
            }
        }

        codeBuilder.AppendLine("""
}
""");

        emitParams.Context.AddSource($"I{emitParams.BaseFileName}.g.cs", codeBuilder.ToString());
    }

    private static void EmitExpressionProperties(EmitterImplParams emitParams)
    {
        StringBuilder codeBuilder = new StringBuilder().AppendLine($$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;
using Spangle.LusterBits;

{{emitParams.NameSpace}}

{{emitParams.TypeAccessibility}} unsafe partial struct {{emitParams.TypeSymbol.Name}}{{emitParams.InterfaceImplementation}}
{
""");
        var pos = 0;
        var lastLen = 0;
        // fields to create ***AsSpan()
        var targetFields = new Dictionary<string, int>();

        foreach (var attr in emitParams.PropDefs)
        {
            string name = attr.TargetField.Name;
            if (!targetFields.ContainsKey(name))
            {
                // Read option to determine the size of Span.
                object? argVal = attr.TargetField.GetAttributes()
                    .FirstOrDefault(x => x.AttributeClass?.Name is OptionsAttributeName)?
                    .ConstructorArguments.First().Value;
                int val = argVal is not null
                    ? (int)argVal
                    : -1; // Auto
                targetFields[name] = val;
            }

            pos = attr.Position == AutoPosition
                ? pos + lastLen
                : attr.Position;

            if (attr.Description is not null)
            {
                codeBuilder.AppendLine($$"""
    /// <summary>
    /// {{attr.Description}}
    /// </summary>
""");
            }

            try
            {
                codeBuilder.AppendLine($$"""
    public {{GetSuitableTypeName(attr.PropType)}} {{attr.PropName}} => {{GetExpression(name, attr, pos)}};

""");
            }
            catch (ArgumentException)
            {
                emitParams.Context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotSupportedTypeField,
                    emitParams.TypeNode.Identifier.GetLocation(), attr.PropType));
                return;
            }
            catch (InvalidDataException)
            {
                emitParams.Context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.InvalidByteBoundary,
                    emitParams.TypeNode.Identifier.GetLocation(), attr.PropType));
                return;
            }

            lastLen = attr.Length;
        }

        // Create {FieldName}AsSpan
        foreach (string fieldName in targetFields.Keys)
        {
            int size = targetFields[fieldName];
            if (size <= 0) // Auto or invalid
            {
                size = Math.Max(1, (int)Math.Ceiling((pos + lastLen) / (float)BitsPerByte));
            }

            codeBuilder.AppendLine($$"""
    internal Span<byte> {{GetMethodNameForFieldAsSpan(fieldName)}}()
    {
        fixed (byte* ptr = {{fieldName}})
        {
            return new Span<byte>(ptr, {{size}});
        }
    }
""");
        }

        codeBuilder.AppendLine("""
}
""");

        emitParams.Context.AddSource($"{emitParams.BaseFileName}.g.cs", codeBuilder.ToString());
    }

    private static string GetMethodNameForFieldAsSpan(string fieldName)
    {
        // _data, m_Data => Data
        if (fieldName.StartsWith("m_"))
        {
            fieldName = fieldName.TrimStart('m');
        }

        fieldName = fieldName.TrimStart('_');
        TextInfo info = CultureInfo.InvariantCulture.TextInfo;
        return $"{info.ToTitleCase(fieldName).Replace(" ", string.Empty)}AsSpan";
    }

    private static void EmitDeserializedStruct(EmitterImplParams emitParams)
    {
        const string nameSuffix = "Deserialized";

        StringBuilder codeBuilder = new StringBuilder().AppendLine($$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;

{{emitParams.NameSpace}}

/// <summary>
/// Deserialized instance of {{emitParams.TypeSymbol.Name}}
/// </summary>
{{emitParams.TypeAccessibility}} readonly partial struct {{emitParams.TypeSymbol.Name}}{{nameSuffix}}{{emitParams.InterfaceImplementation}}
{
""");
        var defs = emitParams.PropDefs.ToArray();
        foreach (var attr in defs)
        {
            if (attr.Description is not null)
            {
                codeBuilder.AppendLine($$"""
    /// <summary>
    /// {{attr.Description}}
    /// </summary>
""");
            }

            try
            {
                codeBuilder.AppendLine($$"""
    public required {{GetSuitableTypeName(attr.PropType)}} {{attr.PropName}} { get; init; }

""");
            }
            catch (ArgumentException)
            {
                emitParams.Context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotSupportedTypeField,
                    emitParams.TypeNode.Identifier.GetLocation(), attr.PropType));
                return;
            }
        }

        codeBuilder.AppendLine($$"""
    public static {{emitParams.TypeSymbol.Name}}{{nameSuffix}} FromBitFields({{emitParams.TypeSymbol.Name}} source)
    {
        return new {{emitParams.TypeSymbol.Name}}{{nameSuffix}}
        {
""");
        foreach (var attr in defs)
        {
            codeBuilder.AppendLine($$"""
            {{attr.PropName}} = source.{{attr.PropName}},
"""
            );
        }

        codeBuilder.AppendLine("""
        };
    }
}
""");

        emitParams.Context.AddSource($"{emitParams.BaseFileName}{nameSuffix}.g.cs", codeBuilder.ToString());
    }

    private static string GetExpression(string slicedFieldName, BitFieldInternal attr, int pos)
    {
        // `pos` explains a position of a bit in whole byte array.
        int firstByte = pos / BitsPerByte;
        int lastByte = (int)Math.Ceiling((float)(pos + attr.Length) / BitsPerByte) - 1;
        int posFirstDataBitInThisByte = pos % BitsPerByte;
        int numUnconsumedBits = attr.Length;
        int totalDataBytes = lastByte - firstByte + 1;
        // Base amount of right shift over all bytes
        int shiftForBottom =
            ((pos + attr.Length) % BitsPerByte - BitsPerByte) % BitsPerByte; // minus value (right shift)
        int endPosOfAllBytes = pos + attr.Length - 1;

        if (IsStringType(attr.PropType))
        {
            return GetStringExpression(slicedFieldName, attr, pos);
        }

        // Some casts are required to avoid overflow on shift operation.
        string innerCast = attr.PropType.SpecialType is SpecialType.System_UInt32 or SpecialType.System_UInt64
            or SpecialType.System_Int64
            ? $"({GetSuitableTypeName(attr.PropType)})"
            : "";

        StringBuilder sb = new StringBuilder();

        sb.Append(GetConverter(GetSuitableTypeName(attr.PropType)));

        sb.Append("(");
        {
            // current byte order from firstByte
            var numByteOrder = 1;
            // Create formulas for all bytes involved and sum them.
            for (int curByte = firstByte; curByte <= lastByte; curByte++)
            {
                int bitsInThisByte = Math.Min(numUnconsumedBits, BitsPerByte) - posFirstDataBitInThisByte;
                int shiftForByteOrder = BitsPerByte * (totalDataBytes - numByteOrder); // Big-Endian
                int shift = shiftForByteOrder + shiftForBottom;
                // Last bit position of this byte to use
                int lastDataBitInThisByte = Math.Min(endPosOfAllBytes - BitsPerByte * curByte, PosLastBit);

                byte mask = 0xFF;

                if (posFirstDataBitInThisByte > 0)
                {
                    mask &= (byte)((1 << (BitsPerByte - posFirstDataBitInThisByte)) - 1);
                }

                // Modify mask only when the all previous bits in this byte are not used to avoid unnecessary masking.
                if (lastDataBitInThisByte < PosLastBit && posFirstDataBitInThisByte > 0)
                {
                    mask &= (byte)~(0xFF >>> (lastDataBitInThisByte + 1));
                }

                string masked = mask != 0xFF
                    ? $"{innerCast}({slicedFieldName}[{curByte}] & 0x{mask:X2})"
                    : $"{innerCast}{slicedFieldName}[{curByte}]";

                string expressionForThisByte = shift switch
                {
                    > 0 => $"{masked} << {shift}",
                    < 0 => $"{masked} >>> {-shift}",
                    _   => masked
                };

                // End of current byte
                if (curByte != lastByte)
                {
                    // Have next byte to append.
                    // Must be enclosed in parentheses to prevent right-associativity of the right side value of the shift.
                    // e.g. (firstByteMember) + ... + (currentByteMember) +
                    sb.AppendFormat("({0}) + ", expressionForThisByte);
                    numByteOrder++;
                    posFirstDataBitInThisByte = 0;
                    numUnconsumedBits -= bitsInThisByte;
                }
                else
                {
                    // End of byte data range
                    if (numByteOrder > 1)
                    {
                        // End of multiple bytes data range. We must care about right-associativity of the shift.
                        // e.g. (firstByteMember) + ... + (lastByteMember)
                        sb.AppendFormat("({0})", expressionForThisByte);
                    }
                    else
                    {
                        // Single byte data does not need to be enclosed in parentheses.
                        // e.g. firstByteMember
                        sb.Append(expressionForThisByte);
                        // End of byte data range
                    }
                }
            }
        }
        sb.Append(")");

        return sb.ToString();
    }

    private static string GetStringExpression(string slicedFieldName, BitFieldInternal attr, int pos)
    {
        if (pos % BitsPerByte != 0 || attr.Length % BitsPerByte != 0)
        {
            throw new InvalidDataException("String fields must be adjusted to byte boundaries.");
        }

        // `Spangle.LusterBits` is included for the charmed struct
        string propType = attr.PropType.SpecialType == SpecialType.System_String
            ? "UTF8String"
            : attr.PropType.Name;

        return
            $"new {propType}({GetMethodNameForFieldAsSpan(slicedFieldName)}().Slice({pos / BitsPerByte}, {attr.Length / BitsPerByte})).ToString()";
    }

    private static bool IsStringType(ITypeSymbol symbol)
    {
        return symbol.ToDisplayString()
                   is "Spangle.LusterBits.UTF8String"
                   or "Spangle.LusterBits.UTF16String"
                   or "Spangle.LusterBits.UTF16BigEndianString"
               || symbol.SpecialType == SpecialType.System_String;
    }

    /// <summary>
    /// Get converter expression for the provided type name.
    /// Usually, it returns a cast expression. But for special types, it returns a specific expression.
    /// </summary>
    /// <param name="suitableTypeName"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    private static string GetConverter(string suitableTypeName)
    {
        return suitableTypeName switch
        {
            // Expected 1 bit length field for bool type so the value is always 0 or 1.
            "bool" => "0 != ",
            // Cast expression for almost all types.
            _ => "(" + suitableTypeName + ")",
        };
    }

    /// <summary>
    /// Gets the suitable type name for the provided INamedTypeSymbol instance.
    /// </summary>
    /// <remarks>
    /// This method returns the C# keyword for the type if available. (e.g., "int" instead of "Int32").
    /// For types without a specific keyword, it returns the fully qualified name, including the namespace.
    /// </remarks>
    /// <param name="type">The INamedTypeSymbol instance for which to get the suitable type name.</param>
    /// <returns>The suitable type name for the provided type. This will be a C# keyword if one exists for the type, or the fully qualified name otherwise.</returns>
    private static string GetSuitableTypeName(INamedTypeSymbol type)
    {
        if (type.TypeKind == TypeKind.Enum)
        {
            return type.ToDisplayString();
        }

        if (IsStringType(type))
        {
            return "string";
        }

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => "bool",
            SpecialType.System_SByte   => "sbyte",
            SpecialType.System_Byte    => "byte",
            SpecialType.System_Int16   => "short",
            SpecialType.System_UInt16  => "ushort",
            SpecialType.System_Int32   => "int",
            SpecialType.System_UInt32  => "uint",
            SpecialType.System_Int64   => "long",
            SpecialType.System_UInt64  => "ulong",
            SpecialType.System_Decimal => "decimal",
            SpecialType.System_Single  => "float",
            SpecialType.System_Double  => "double",
            _                          => throw new ArgumentException($"unsupported type: {type}", nameof(type)),
        };
    }

    private class EmitterImplParams
    {
        public required SourceProductionContext Context { get; init; }
        public required INamedTypeSymbol TypeSymbol { get; init; }
        public required TypeDeclarationSyntax TypeNode { get; init; }
        public required bool HasInterface { get; init; }
        public required string BaseFileName { get; init; }
        public required string NameSpace { get; init; }
        public required string TypeAccessibility { get; init; }
        public required BitFieldInternal[] PropDefs { get; init; }

        public string InterfaceImplementation => HasInterface ? " : I" + TypeSymbol.Name : "";
    }

    /// <summary>
    /// BitField instance for internal use.
    /// </summary>
    private record BitFieldInternal(IFieldSymbol TargetField, INamedTypeSymbol PropType, string PropName, int Length,
        int Position,
        string? Description)
    {
        public static BitFieldInternal FromConstructorArgs(IFieldSymbol target, AttributeData data)
        {
            var args = data.ConstructorArguments;
            return new BitFieldInternal(
                target,
                (INamedTypeSymbol)args[0].Value!,
                (string)args[1].Value!,
                (int)args[2].Value!,
                (int)args[3].Value!,
                (string)args[4].Value!
            );
        }
    }
}
